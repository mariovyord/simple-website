<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mario Yordanov | Front-End Engineer</title>
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='black'/%3E%3Ctext x='7' y='23' font-size='20' font-family='monospace' fill='%2300FF00'%3E%3E_%3C/text%3E%3C/svg%3E"
    />
    <style>
      :root {
        --terminal-green: #0f0;
        --terminal-green-dim: rgba(0, 255, 0, 0.2);
        --terminal-yellow: #ff0;
        --bg-dark: #000;
        --bg-panel: rgba(0, 20, 0, 0.85);
        --border-glow: 0 0 10px rgba(0, 255, 0, 0.5);
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
      body {
        font-family: "Courier New", monospace;
        background-color: var(--bg-dark);
        color: var(--terminal-green);
        min-height: 100vh;
        width: 100vw;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: fixed;
      }
      .info-panel {
        background: var(--bg-panel);
        border: 1px solid var(--terminal-green);
        border-radius: 5px;
        padding: 28px 20px;
        box-shadow: var(--border-glow);
        max-width: 95vw;
        width: 380px;
        z-index: 10;
        box-sizing: border-box;
      }
      .terminal-header {
        position: relative;
        padding-top: 25px;
        padding-bottom: 25px;
        margin-bottom: 15px;
        border-bottom: 1px solid var(--terminal-green-dim);
      }
      .terminal-header::before {
        content: "$ terminal_bio ~";
        position: absolute;
        top: -28px;
        left: -20px;
        right: -20px;
        height: 24px;
        background-color: rgba(0, 40, 0, 0.9);
        border-bottom: 1px solid var(--terminal-green);
        color: var(--terminal-green);
        font-size: 0.8em;
        padding: 2px 10px;
        display: flex;
        align-items: center;
        border-radius: 5px 5px 0 0;
      }
      .info-panel h1 {
        font-size: 1.3em;
        margin-bottom: 10px;
        color: var(--terminal-green);
        font-weight: bold;
      }
      .info-panel p,
      .info-panel div {
        margin-bottom: 15px;
        line-height: 1.6;
      }
      .section {
        margin-bottom: 20px;
        position: relative;
      }
      .section::before {
        content: ">";
        position: absolute;
        left: -15px;
        color: var(--terminal-green);
      }
      .info-panel a {
        color: var(--terminal-yellow);
        text-decoration: none;
        border-bottom: 1px dashed var(--terminal-yellow);
        transition: all 0.2s ease;
      }
      .info-panel a:hover {
        color: #fff;
        border-bottom: 1px solid #fff;
      }
      .blinking-cursor::after {
        content: "|";
        animation: blink 1s step-end infinite;
      }
      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
      }
      /* Switch button styles */
      .switch-btn {
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--bg-panel);
        border: 1px solid var(--terminal-green);
        color: var(--terminal-green);
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        font-family: inherit;
        font-size: 0.9em;
        transition: all 0.3s ease;
        z-index: 20;
      }
      .switch-btn:hover {
        background: var(--terminal-green);
        color: var(--bg-dark);
      }
      .game-container {
        position: absolute;
        width: 380px;
        max-width: 95vw;
        height: 450px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .game-container.active {
        opacity: 1;
        pointer-events: all;
      }
      .info-panel.hidden {
        opacity: 0;
        pointer-events: none;
      }
      #canvas {
        border: 1px solid var(--terminal-green);
        border-radius: 5px;
        box-shadow: var(--border-glow);
        background: var(--bg-panel);
        width: 100%;
        height: 100%;
      }

      @media (max-width: 600px) {
        .info-panel {
          padding: 20px;
        }
        .terminal-header {
          padding-top: 20px;
          padding-bottom: 20px;
        }
        .section {
          margin-bottom: 15px;
        }
        .info-panel h1 {
          font-size: 1.2em;
        }
        .info-panel p,
        .info-panel div {
          margin-bottom: 10px;
        }
        .switch-btn {
          padding: 6px 12px;
          font-size: 0.8em;
        }
        .game-container {
          height: 400px;
        }
        #canvas {
          height: 100%;
        }
      }
    </style>
  </head>
  <body>
    <button class="switch-btn" onclick="toggleView()">Play Game</button>

    <div class="info-panel">
      <div class="terminal-header">
        <h1 class="blinking-cursor">Hi, I'm Mario Yordanov</h1>
        <p>Front-End Engineer based in Bulgaria</p>
      </div>
      <div class="section">
        <p>Let's connect! Reach out to me at:</p>
        <p>
          ðŸ“§
          <a href="mailto:mariovyordanov@gmail.com">mariovyordanov@gmail.com</a>
        </p>
        <p>
          ðŸ’¼
          <a href="https://www.linkedin.com/in/mariovyordanov/" target="_blank"
            >linkedin.com/in/mariovyordanov</a
          >
        </p>
        <p>
          ðŸ’»
          <a href="https://github.com/mariovyord" target="_blank"
            >github.com/mariovyord</a
          >
        </p>
      </div>
    </div>

    <div class="game-container">
      <canvas id="canvas"></canvas>
    </div>

    <script>
      let isGame = false;
      let gameInstance = null;

      function toggleView() {
        const btn = document.querySelector(".switch-btn");
        const bio = document.querySelector(".info-panel");
        const game = document.querySelector(".game-container");

        isGame = !isGame;

        if (isGame) {
          btn.textContent = "Show Bio";
          bio.classList.add("hidden");
          game.classList.add("active");
          // Initialize game if not already initialized
          if (!window.gameInitialized) {
            gameInstance = initGame();
          } else {
            // Reset the game when switching back to it
            gameInstance.reset();
            gameInstance.start();
          }
        } else {
          btn.textContent = "Play Game";
          bio.classList.remove("hidden");
          game.classList.remove("active");
        }
      }

      function initGame() {
        const canvas = document.getElementById("canvas");
        const container = document.querySelector(".game-container");
        const bio = document.querySelector(".info-panel");

        // Set canvas size to match bio panel size
        const bioHeight = bio.offsetHeight;
        canvas.width = container.offsetWidth;
        canvas.height = bioHeight;
        container.style.height = `${bioHeight}px`;

        window.gameInitialized = true;

        /** @type {CanvasRenderingContext2D} */
        const ctx = canvas.getContext("2d");

        class Game {
          constructor(canvas, ctx) {
            this.canvas = canvas;
            this.ctx = ctx;
            this.reset();

            // Event listeners for keyboard
            window.addEventListener("keydown", (e) => {
              if (e.key === "ArrowLeft") this.keys.left = true;
              if (e.key === "ArrowRight") this.keys.right = true;
            });

            window.addEventListener("keyup", (e) => {
              if (e.key === "ArrowLeft") this.keys.left = false;
              if (e.key === "ArrowRight") this.keys.right = false;
            });

            // Touch controls
            let touchStartX = null;

            this.canvas.addEventListener(
              "touchstart",
              (e) => {
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
              },
              { passive: false }
            );

            this.canvas.addEventListener(
              "touchmove",
              (e) => {
                e.preventDefault();
                if (touchStartX === null) return;

                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartX;

                // Update player position directly
                const newX = this.player.x + deltaX;
                this.player.x = Math.max(
                  0,
                  Math.min(this.canvas.width - this.player.width, newX)
                );

                touchStartX = touch.clientX;
              },
              { passive: false }
            );

            this.canvas.addEventListener(
              "touchend",
              (e) => {
                e.preventDefault();
                touchStartX = null;
              },
              { passive: false }
            );
          }

          reset() {
            this.player = {
              x: this.canvas.width / 2,
              y: this.canvas.height - 30,
              width: 30,
              height: 30,
              speed: 5,
            };
            this.obstacles = [];
            this.score = 0;
            this.gameOver = false;
            this.keys = {
              left: false,
              right: false,
            };
          }

          spawnObstacle() {
            const width = 20;
            const obstacle = {
              x: Math.random() * (this.canvas.width - width),
              y: 0,
              width: width,
              height: 20,
              speed: 3,
            };
            this.obstacles.push(obstacle);
          }

          updatePlayer() {
            // Move player based on input
            if (this.keys.left && this.player.x > 0) {
              this.player.x -= this.player.speed;
            }
            if (
              this.keys.right &&
              this.player.x < this.canvas.width - this.player.width
            ) {
              this.player.x += this.player.speed;
            }
          }

          updateObstacles() {
            // Move obstacles down
            for (let i = this.obstacles.length - 1; i >= 0; i--) {
              const obstacle = this.obstacles[i];
              obstacle.y += obstacle.speed;

              // Remove obstacles that are off screen
              if (obstacle.y > this.canvas.height) {
                this.obstacles.splice(i, 1);
                this.score += 10;
              }

              // Check for collision with player
              if (this.checkCollision(this.player, obstacle)) {
                this.gameOver = true;
              }
            }
          }

          checkCollision(rect1, rect2) {
            return (
              rect1.x < rect2.x + rect2.width &&
              rect1.x + rect1.width > rect2.x &&
              rect1.y < rect2.y + rect2.height &&
              rect1.y + rect1.height > rect2.y
            );
          }

          draw() {
            // Clear canvas
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // Draw background
            this.ctx.fillStyle = "rgba(0, 20, 0, 0.85)";
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Draw player
            this.ctx.fillStyle = "#0f0";
            this.ctx.fillRect(
              this.player.x,
              this.player.y,
              this.player.width,
              this.player.height
            );

            // Draw obstacles
            this.ctx.fillStyle = "red";
            this.obstacles.forEach((obstacle) => {
              this.ctx.fillRect(
                obstacle.x,
                obstacle.y,
                obstacle.width,
                obstacle.height
              );
            });

            // Draw score
            this.ctx.fillStyle = "#0f0";
            this.ctx.font = "20px Courier New";
            this.ctx.textAlign = "left";
            this.ctx.fillText(`Score: ${this.score}`, 10, 30);

            // Draw game over text
            if (this.gameOver) {
              this.ctx.fillStyle = "#0f0";
              this.ctx.font = "40px Courier New";
              this.ctx.textAlign = "center";
              this.ctx.fillText(
                "GAME OVER",
                this.canvas.width / 2,
                this.canvas.height / 2
              );
            }
          }

          start() {
            if (this.gameOver) return;

            // Spawn obstacles periodically
            if (Math.random() < 0.02) {
              // Adjust this value to change obstacle frequency
              this.spawnObstacle();
            }

            this.updatePlayer();
            this.updateObstacles();
            this.draw();

            // Continue the game loop
            requestAnimationFrame(() => this.start());
          }
        }

        // Initialize the game
        const game = new Game(canvas, ctx);
        game.start();
        return game;
      }
    </script>
  </body>
</html>
